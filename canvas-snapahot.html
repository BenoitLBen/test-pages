<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set & SHA256 Snapshots</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 12px;
            background-color: #000; /* Default background for Mandelbrot */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex flex-col items-center p-6 bg-white rounded-lg shadow-xl max-w-4xl mx-auto space-y-6">
        <h1 class="text-3xl font-bold text-gray-900 mb-4">Mandelbrot Set Explorer</h1>
        <p class="text-lg text-gray-600 text-center">
            Watch the Mandelbrot set animate with cycling colors. Every second, a PNG snapshot is taken and its SHA256 hash is displayed below.
        </p>

        <canvas id="mandelbrotCanvas" width="600" height="600" class="w-full h-auto max-w-full"></canvas>

        <div id="hashDisplay" class="mt-4 p-4 bg-blue-50 text-blue-800 rounded-lg text-sm md:text-base font-mono break-all text-center">
            SHA256: Calculating...
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mandelbrotCanvas');
        const ctx = canvas.getContext('2d');
        const hashDisplay = document.getElementById('hashDisplay');

        // Mandelbrot parameters
        const MAX_ITERATIONS = 100;
        const BAILOUT = 2; // If |z| exceeds this, the point is outside the set
        const zoom = 250; // Controls the "zoom" level
        const offsetX = -2.0; // Pan X to center
        const offsetY = -1.5; // Pan Y to center

        let colorOffset = 0; // For color cycling
        let animationFrameId; // To control the animation loop
        let snapshotIntervalId; // To control the snapshot interval

        // Function to convert base64 string to Uint8Array
        function base64ToUint8Array(base64) {
            const raw = atob(base64);
            const rawLength = raw.length;
            const array = new Uint8Array(new ArrayBuffer(rawLength));
            for (let i = 0; i < rawLength; i++) {
                array[i] = raw.charCodeAt(i);
            }
            return array;
        }

        // Function to convert ArrayBuffer to hex string
        function bufferToHex(buffer) {
            return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
        }

        // Draws the Mandelbrot set on the canvas
        function drawMandelbrot() {
            // Get the image data for direct pixel manipulation
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const pixels = imageData.data;

            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    // Map pixel coordinates to complex plane
                    const c_re = (px - canvas.width / 2) / zoom + offsetX + (canvas.width / 2 / zoom);
                    const c_im = (py - canvas.height / 2) / zoom + offsetY + (canvas.height / 2 / zoom);

                    let z_re = 0;
                    let z_im = 0;
                    let numIterations = 0;

                    // Mandelbrot iteration
                    while (numIterations < MAX_ITERATIONS) {
                        const z_re2 = z_re * z_re;
                        const z_im2 = z_im * z_im;

                        // Check if the point escapes the bailout radius
                        if (z_re2 + z_im2 > BAILOUT * BAILOUT) {
                            break;
                        }

                        // Calculate next z: z = z*z + c
                        const next_z_re = z_re2 - z_im2 + c_re;
                        const next_z_im = 2 * z_re * z_im + c_im;
                        z_re = next_z_re;
                        z_im = next_z_im;

                        numIterations++;
                    }

                    // Determine pixel index in the image data array
                    const pixelIndex = (py * canvas.width + px) * 4;

                    // Color based on escape time (or black if it's in the set)
                    if (numIterations === MAX_ITERATIONS) {
                        // Point is likely in the set, color black
                        pixels[pixelIndex] = 0;     // R
                        pixels[pixelIndex + 1] = 0; // G
                        pixels[pixelIndex + 2] = 0; // B
                        pixels[pixelIndex + 3] = 255; // A (opaque)
                    } else {
                        // Point escaped, color based on iteration count and color offset
                        // Using HSL to cycle colors smoothly
                        const hue = (numIterations / MAX_ITERATIONS * 360 + colorOffset) % 360;
                        const saturation = 100; // Fixed saturation
                        const lightness = 50 + (numIterations / MAX_ITERATIONS * 40); // Vary lightness for more depth

                        // Convert HSL to RGB
                        // (Simplified HSL to RGB conversion for illustration)
                        function hslToRgb(h, s, l) {
                            s /= 100;
                            l /= 100;
                            let c = (1 - Math.abs(2 * l - 1)) * s,
                                x = c * (1 - Math.abs((h / 60) % 2 - 1)),
                                m = l - c / 2,
                                r = 0,
                                g = 0,
                                b = 0;

                            if (0 <= h && h < 60) {
                                r = c; g = x; b = 0;
                            } else if (60 <= h && h < 120) {
                                r = x; g = c; b = 0;
                            } else if (120 <= h && h < 180) {
                                r = 0; g = c; b = x;
                            } else if (180 <= h && h < 240) {
                                r = 0; g = x; b = c;
                            } else if (240 <= h && h < 300) {
                                r = x; g = 0; b = c;
                            } else if (300 <= h && h < 360) {
                                r = c; g = 0; b = x;
                            }
                            r = Math.round((r + m) * 255);
                            g = Math.round((g + m) * 255);
                            b = Math.round((b + m) * 255);

                            return [r, g, b];
                        }

                        const [r, g, b] = hslToRgb(hue, saturation, lightness);
                        pixels[pixelIndex] = r;
                        pixels[pixelIndex + 1] = g;
                        pixels[pixelIndex + 2] = b;
                        pixels[pixelIndex + 3] = 255; // Opaque
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Animation loop to cycle colors
        function animate() {
            colorOffset = (colorOffset + 1) % 360; // Increment hue offset
            drawMandelbrot();
            animationFrameId = requestAnimationFrame(animate);
        }

        // Takes a PNG snapshot of the canvas and calculates its SHA256 hash
        async function takeSnapshotAndHash() {
            try {
                // Get the data URL of the canvas as a PNG image
                const dataURL = canvas.toDataURL('image/png');

                // Extract the base64 encoded image data (remove the "data:image/png;base64," prefix)
                const base64 = dataURL.split(',')[1];

                // Convert the base64 string to a Uint8Array
                const uint8Array = base64ToUint8Array(base64);

                // Calculate the SHA256 hash of the Uint8Array
                const hashBuffer = await crypto.subtle.digest('SHA-256', uint8Array);

                // Convert the ArrayBuffer hash to a hexadecimal string
                const hashHex = bufferToHex(hashBuffer);

                // Display the hash
                hashDisplay.textContent = `SHA256: ${hashHex}`;
            } catch (error) {
                console.error("Error taking snapshot or calculating SHA256:", error);
                hashDisplay.textContent = "SHA256: Error calculating hash.";
            }
        }

        // Initialize on window load
        window.onload = function() {
            // Start the Mandelbrot animation
            animate();

            // Start taking snapshots and calculating hash every second
            snapshotIntervalId = setInterval(takeSnapshotAndHash, 1000);
        };

        // Cleanup function if needed (e.g., when navigating away from the page)
        window.onbeforeunload = function() {
            cancelAnimationFrame(animationFrameId);
            clearInterval(snapshotIntervalId);
        };
    </script>
</body>
</html>
