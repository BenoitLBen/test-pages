<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Pointer Lock Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            color: #f8fafc;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        .ui-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(15, 23, 42, 0.8);
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease;
        }
        #fps-counter {
            top: 1rem;
            left: 1rem;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: #4ade80;
            font-size: 1.2rem;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        #status {
            bottom: 1rem;
            right: 1rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="fps-counter" class="ui-overlay">FPS: 0</div>
    
    <div id="instructions" class="ui-overlay">
        <h1 class="text-3xl font-bold mb-4">WebGL Workspace</h1>
        <p class="mb-6 text-slate-300">Click anywhere to capture your mouse pointer.<br>Move the mouse to rotate the cube.</p>
        <div class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg inline-block font-semibold pointer-events-auto cursor-pointer transition-colors" id="start-btn">
            Enter Viewport
        </div>
        <p class="mt-4 text-xs text-slate-500">Press ESC to release the pointer</p>
    </div>

    <div id="status" class="ui-overlay">Pointer Status: Released</div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, cube;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        
        const container = document.getElementById('canvas-container');
        const instructions = document.getElementById('instructions');
        const fpsDisplay = document.getElementById('fps-counter');
        const statusDisplay = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            
            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Cube Setup
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            // MeshNormalMaterial maps normals to RGB colors - looks great without lights
            const material = new THREE.MeshNormalMaterial();
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // Add basic wireframe for better depth perception
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
            );
            cube.add(wireframe);

            setupPointerLock();
            animate();
        }

        function setupPointerLock() {
            const requestPointerLock = () => {
                container.requestPointerLock = container.requestPointerLock || container.mozRequestPointerLock;
                container.requestPointerLock();
            };

            // Trigger on button click or container click
            startBtn.addEventListener('click', requestPointerLock);
            container.addEventListener('click', requestPointerLock);

            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

            function lockChangeAlert() {
                if (document.pointerLockElement === container || document.mozPointerLockElement === container) {
                    console.log('The pointer lock status is now locked');
                    instructions.classList.add('hidden');
                    statusDisplay.textContent = "Pointer Status: Captured";
                    statusDisplay.classList.add('text-indigo-400');
                    document.addEventListener("mousemove", updateRotation, false);
                } else {
                    console.log('The pointer lock status is now unlocked');
                    instructions.classList.remove('hidden');
                    statusDisplay.textContent = "Pointer Status: Released";
                    statusDisplay.classList.remove('text-indigo-400');
                    document.removeEventListener("mousemove", updateRotation, false);
                }
            }
        }

        function updateRotation(e) {
            // Apply mouse movement to cube rotation
            const sensitivity = 0.002;
            cube.rotation.y += e.movementX * sensitivity;
            cube.rotation.x += e.movementY * sensitivity;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Base rotation (passive)
            cube.rotation.x += 0.005;
            cube.rotation.y += 0.005;

            // FPS Calculation
            frameCount++;
            const time = performance.now();
            if (time >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (time - lastTime));
                fpsDisplay.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = time;
            }

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>
