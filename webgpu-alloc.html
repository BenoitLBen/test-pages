<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Memory Allocation Test</title>
    <!-- Tailwind CSS for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            padding: 1rem;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 10px 20px rgba(0, 0, 0, 0.07);
            max-width: 90%;
            width: 500px;
            text-align: center;
        }
        .button-primary {
            @apply bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-300 ease-in-out;
        }
        .button-danger {
            @apply bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-300 ease-in-out;
        }
        .message-box {
            background-color: #4a5568;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1.5rem;
            min-height: 100px;
            text-align: left;
            overflow-y: auto;
            max-height: 300px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap; /* Preserve whitespace and wrap long lines */
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container flex flex-col items-center">
        <h1 class="text-3xl font-bold mb-4">WebGPU Memory Exhaustion Test</h1>
        <p class="text-md mb-6">Click the button to allocate large WebGPU buffers until memory allocation fails.</p>

        <div class="flex space-x-4 mb-6">
            <button id="startButton" class="button-primary">Start Allocation Test</button>
            <button id="stopButton" class="button-danger" disabled>Stop Test</button>
        </div>

        <div id="loadingSpinner" class="loading-spinner mb-4"></div>

        <div id="messageBox" class="message-box w-full text-sm">
            <p>Waiting to start...</p>
        </div>
    </div>

    <script type="module">
        // Global variables for WebGPU objects
        let adapter = null;
        let device = null;
        let buffers = [];
        let running = false;
        let allocationSize = 256 * 1024 * 1024; // 256 MB per buffer
        let totalAllocatedBytes = 0;
        let allocationCount = 0;

        // UI elements
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const messageBox = document.getElementById('messageBox');
        const loadingSpinner = document.getElementById('loadingSpinner');

        /**
         * Appends a message to the message box.
         * @param {string} message - The message to append.
         */
        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            messageBox.appendChild(p);
            // Scroll to the bottom to show the latest message
            messageBox.scrollTop = messageBox.scrollHeight;
        }

        /**
         * Clears all messages from the message box.
         */
        function clearMessages() {
            messageBox.innerHTML = '';
        }

        /**
         * Initializes WebGPU adapter and device.
         * @returns {Promise<boolean>} True if successful, false otherwise.
         */
        async function initializeWebGPU() {
            logMessage("Attempting to initialize WebGPU...");
            if (!navigator.gpu) {
                logMessage("Error: WebGPU is not supported in this browser.");
                return false;
            }

            try {
                // Request a GPU adapter
                adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    logMessage("Error: No WebGPU adapter found.");
                    return false;
                }
                logMessage(`Adapter found: ${adapter.name || 'Unknown Adapter'}`);

                // Request a GPU device from the adapter
                device = await adapter.requestDevice();
                if (!device) {
                    logMessage("Error: Could not obtain a WebGPU device.");
                    return false;
                }
                logMessage("WebGPU device successfully obtained.");

                // Set an error handler for the device
                device.lost.then((info) => {
                    logMessage(`WebGPU device was lost: ${info.message}`);
                    logMessage("Test stopped due to device loss.");
                    stopAllocationTest();
                });

                return true;
            } catch (error) {
                logMessage(`Error during WebGPU initialization: ${error.message}`);
                return false;
            }
        }

        /**
         * Formats bytes into a human-readable string (KB, MB, GB).
         * @param {number} bytes - The number of bytes.
         * @returns {string} Formatted size string.
         */
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /**
         * Attempts to allocate a single large buffer and fill it with random data.
         * @returns {Promise<boolean>} True if allocation and filling were successful, false otherwise.
         */
        async function allocateBuffer() {
            try {
                // Determine buffer usage:
                // MAP_READ: Allows reading the buffer contents on the CPU.
                // COPY_SRC: Allows copying data FROM this buffer.
                // MAP_WRITE: Allows writing to the buffer contents on the CPU.
                // COPY_DST: Allows copying data TO this buffer from a command encoder.
                // STORAGE: Makes it a general-purpose buffer usable in compute/render shaders.
                const usage = GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_SRC |
                              GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE;

                // Create the GPU buffer and immediately map it for writing.
                // mappedAtCreation: true allows direct access to the buffer's memory immediately.
                const buffer = device.createBuffer({
                    size: allocationSize,
                    usage: usage,
                    mappedAtCreation: true, // New: Maps the buffer for writing immediately upon creation.
                });

                // Get the raw ArrayBuffer view from the mapped range.
                const arrayBuffer = buffer.getMappedRange();

                // Create a TypedArray view over the mapped range to fill with data.
                // Using Uint32Array for efficiency, assuming allocationSize is a multiple of 4 bytes.
                const dataView = new Uint32Array(arrayBuffer);

                // Fill the TypedArray with random 32-bit integers.
                for (let i = 0; i < dataView.length; ++i) {
                    dataView[i] = Math.floor(Math.random() * 0xFFFFFFFF); // Random 32-bit value
                }

                // Unmap the buffer. This makes the data available to the GPU and invalidates the CPU mapping.
                buffer.unmap();

                buffers.push(buffer);
                totalAllocatedBytes += allocationSize;
                allocationCount++;
                logMessage(`Allocated and filled buffer ${allocationCount}: ${formatBytes(allocationSize)}.`);
                logMessage(`Total allocated: ${formatBytes(totalAllocatedBytes)}.`);
                return true;
            } catch (error) {
                logMessage(`Error: Failed to allocate or fill buffer ${allocationCount + 1}!`);
                logMessage(`Reason: ${error.message}`);
                logMessage(`Total successful allocations: ${allocationCount}`);
                logMessage(`Total memory allocated before failure: ${formatBytes(totalAllocatedBytes)}`);
                // Clear all previously allocated buffers when failure occurs,
                // although the device might be in a bad state or lost.
                buffers.forEach(b => b.destroy()); // Destroy all allocated buffers to free up resources
                buffers = [];
                return false;
            }
        }

        /**
         * Main function to start the allocation test.
         */
        async function startAllocationTest() {
            clearMessages();
            startButton.disabled = true;
            stopButton.disabled = false;
            loadingSpinner.style.display = 'block'; // Show spinner
            logMessage("Starting WebGPU memory allocation test...");

            // Reset counters
            buffers = [];
            totalAllocatedBytes = 0;
            allocationCount = 0;

            const webGPULoaded = await initializeWebGPU();
            if (!webGPULoaded) {
                logMessage("WebGPU not available or failed to initialize. Cannot run test.");
                startButton.disabled = false;
                stopButton.disabled = true;
                loadingSpinner.style.display = 'none'; // Hide spinner
                return;
            }

            running = true;
            while (running) {
                const success = await allocateBuffer();
                if (!success) {
                    logMessage("WebGPU memory allocation test finished due to failure.");
                    stopAllocationTest(); // Stop the loop and reset UI
                    break;
                }
                // Small delay to allow browser to update UI or yield thread if necessary
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            loadingSpinner.style.display = 'none'; // Hide spinner if loop finishes normally (e.g. stopped by user)
        }

        /**
         * Stops the memory allocation test.
         */
        function stopAllocationTest() {
            running = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            loadingSpinner.style.display = 'none'; // Hide spinner

            logMessage("Test stopped by user.");
            // Destroy any remaining buffers if the test was manually stopped
            buffers.forEach(b => b.destroy());
            buffers = [];
            totalAllocatedBytes = 0;
            allocationCount = 0;

            if (device) {
                // No explicit device destruction in WebGPU spec for normal use,
                // but if there's a need to release resources quickly,
                // one would rely on device loss or page unload.
                // For this test, we just stop allocating.
            }
        }

        // Event listeners for buttons
        startButton.addEventListener('click', startAllocationTest);
        stopButton.addEventListener('click', stopAllocationTest);

        // Initial message
        logMessage("Click 'Start Allocation Test' to begin.");
    </script>
</body>
</html>
