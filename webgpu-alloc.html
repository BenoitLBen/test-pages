<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Allocator</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; background-color: #1a1a1a; color: #e0e0e0; }
        #info { padding: 10px; background-color: #333; border-bottom: 1px solid #555; display: flex; justify-content: space-between; align-items: center; }
        #info span { margin-right: 20px; }
        #canvas-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; background-color: #000; border: 1px solid #555; }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #444;
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        .message-box button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <span id="adapter-info">Adapter: Not available</span>
        <span id="device-info">Device: Not available</span>
        <span id="size-info">Size: 0 MB</span>
        <span id="rate-info">Rate: 0 MB/s</span>
    </div>
    <div id="canvas-container">
        <canvas id="gpuCanvas"></canvas>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="document.getElementById('messageBox').style.display='none'">OK</button>
    </div>

    <script type="module">
        // Helper function to display messages to the user
        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        async function initWebGPU() {
            if (!navigator.gpu) {
                showMessageBox("WebGPU is not supported in your browser. Please ensure you are using a browser that supports WebGPU and it is enabled.");
                return;
            }

            let adapter;
            try {
                // Request a high-performance adapter to avoid software adapters
                adapter = await navigator.gpu.requestAdapter({
                    powerPreference: "high-performance"
                });

                if (!adapter) {
                    showMessageBox("No WebGPU adapter found or available. Please check your system's GPU drivers.");
                    return;
                }

                document.getElementById('adapter-info').textContent = `Adapter: Found (High Performance Preference)`;
                console.log("WebGPU Adapter found with high-performance preference.");

            } catch (error) {
                console.error("Error requesting WebGPU adapter:", error);
                showMessageBox(`Failed to get WebGPU adapter: ${error.message}`);
                return;
            }

            let device;
            try {
                device = await adapter.requestDevice();
                document.getElementById('device-info').textContent = `Device: OK`;
            } catch (error) {
                console.error("Error requesting WebGPU device:", error);
                showMessageBox(`Failed to get WebGPU device: ${error.message}`);
                return;
            }

            const canvas = document.getElementById('gpuCanvas');
            const context = canvas.getContext('webgpu');

            if (!context) {
                showMessageBox("Could not get WebGPU context from canvas.");
                return;
            }

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format,
                alphaMode: 'opaque',
            });

            const bufferSize = 100 * 1024 * 1024; // 100 MB
            const maxAllocationGiB = 10; // Maximum allocation in GiB
            const maxAllocationBytes = maxAllocationGiB * 1024 * 1024 * 1024; // 10 GiB in bytes

            let currentBuffer = null;
            let lastTime = performance.now();
            let totalAllocated = 0;
            let allocationCount = 0;
            let animationFrameId = null; // To store the requestAnimationFrame ID

            function allocateBuffer() {
                // Stop allocation if maxAllocationBytes is reached
                if (totalAllocated >= maxAllocationBytes) {
                    document.getElementById('rate-info').textContent = `Rate: Allocation Complete`;
                    showMessageBox(`Successfully allocated ${maxAllocationGiB} GiB. Stopping further allocations.`);
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    return;
                }

                try {
                    const newBuffer = device.createBuffer({
                        size: bufferSize,
                        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
                    });

                    // Clear previous buffer if exists to allow GC
                    if (currentBuffer) {
                        currentBuffer.destroy();
                    }
                    currentBuffer = newBuffer;

                    totalAllocated += bufferSize;
                    allocationCount++;

                    const currentTime = performance.now();
                    const deltaTime = (currentTime - lastTime) / 1000; // seconds
                    const currentRate = bufferSize / deltaTime; // Bytes/second

                    document.getElementById('size-info').textContent = `Size: ${(totalAllocated / (1024 * 1024)).toFixed(2)} MB`;
                    document.getElementById('rate-info').textContent = `Rate: ${(currentRate / (1024 * 1024)).toFixed(2)} MB/s`;

                    lastTime = currentTime;

                } catch (e) {
                    console.error("Buffer allocation failed:", e);
                    showMessageBox(`Failed to allocate buffer: ${e.message}. Possible out of memory.`);
                    // Stop further allocations if an error occurs
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    return;
                }

                // Render a small frame to ensure GPU is active
                const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: Math.random(), g: Math.random(), b: Math.random(), a: 1.0 },
                        storeOp: 'store',
                    }],
                });
                passEncoder.end();
                device.queue.submit([commandEncoder.finish()]);

                animationFrameId = requestAnimationFrame(allocateBuffer);
            }

            // Start the allocation process after a short delay to allow UI to render
            setTimeout(() => {
                animationFrameId = requestAnimationFrame(allocateBuffer);
            }, 500); // 500ms delay

            // Handle canvas resizing
            function resizeCanvas() {
                canvas.width = window.innerWidth * 0.8; // Example: 80% of window width
                canvas.height = window.innerHeight * 0.6; // Example: 60% of window height
                // Reconfigure context if needed (important for swap chain recreation)
                if (context) {
                    context.configure({
                        device,
                        format,
                        alphaMode: 'opaque',
                        size: [canvas.width, canvas.height],
                    });
                }
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial resize
        }

        window.onload = initWebGPU;
    </script>
</body>
</html>
